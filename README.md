# C
> 以前课程设计残留的C代码.

# 实验内容
根据题目的要求，编程实现相关信息安全的基本算法，编程语言不限。

# (一)密钥格式化

给定一个密钥字符串S，只包含字母，数字以及 '-'（破折号）。N 个 '-' 将字符串分成了 N+1 组。给定一个数字 K，重新格式化字符串，除了第一个分组以外，每个分组要包含 K 个字符，第一个分组至少要包含 1 个字符。两个分组之间用 '-'（破折号）隔开，并且将所有的小写字母转换为大写字母。

给定非空字符串 S 和数字 K，按照上面描述的规则进行格式化。
示例：

1.输入：S = "5F3Z-2e-9-w", K = 4

输出："5F3Z-2E9W"

解释：字符串 S 被分成了两个部分，每部分 4 个字符；
     注意，两个额外的破折号需要删掉。

2.输入：S = "2-5g-3-J", K = 2

输出："2-5G-3J"

解释：字符串S被分成了3个部分，按照前面的规则描述，第一部分的字符可以少于给定的数量，其余部分皆为 2 个字符。

# （二）旋转函数

给定一个长度为 n 的整数数组A。假设Bk是数组A顺时针旋转k个位置后的数组，我们定义A的“旋转函数”F为：

`F(k) = 0 * Bk[0] + 1 * Bk[1] + ... + (n-1) * Bk[n-1]。`
计算F(0), F(1), ..., F(n-1)中的最大值。

示例:
```
A = [4, 3, 2, 6]
F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25
F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16
F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23
F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26
```
所以F(0),F(1),F(2),F(3)中的最大值是F(3) =26。

# (三)密码宝盒

小M得到了一个宝盒，可惜打开这个宝盒需要一组神奇的密码，然而在宝盒的下面关于密码的提示信息：密码是一个C进制的数,并且只能由给定的M个数字中的某些构成,密码不超过500位，同时密码是一个给定十进制整数N的正整数倍,
如果这样的密码存在,那么你就可以打开宝盒并得到宝贝,如果不存在这样的密码......那你就只能收藏这个宝盒了.

要求:
输入一个T，表示有T组测试数据，(T≤500)
接下来输入N，C，M（N,C，M如上所述）( 0≤N≤5000, 1≤M≤16 , 2≤C≤16 )

然后M个数，表示密码中含有哪些数字。(输入保证合法)
用A来表示10, B来表示11, C来表示12 , D来表示13, E来表示14, F来表示15

输出：密码如果存在，输入最小的那个为密码，不存在”So Sorry.”（密码不含前导零）

# （四）基因编码
输入一个长为 （k≤8）01串s，按照"ABC编码规则"进行编码，ABC编码规则是：
<img src="https://upload.cc/i1/2019/10/07/xQyFjB.png" alt="11.png" title="11.png" />

例如：

<img src="https://upload.cc/i1/2019/10/07/JD0QGh.png" alt="2.png" title="2.png" />

# （五）法雷数列
对任意给定的一个自然数n，将分母小于等于n的不可约的真分数按升序排列，并且在第一个分数之前加上0/1，在最后一个分数之后加上1/1，这个序列称为n级法雷数列，以Fn表示。如F5为：0/1,1/5, 1/4, 1/3, 2/5, 1/2, 3/5, 2/3, 3/4, 4/5,1/1.其元素个数为11.

现在给出n让你求其n级法雷数列中元素的排列和个数。

# （六）折叠加密
给一个长度为 的字符数组和一个长度为k的01数组reg，根据要求编写折叠加密和解密的算法。
折叠加密方法举例：
```
reg[i]=0,表示从左到右折叠
a b c d e f g h  折叠加密后      d c b a
                                e f g h
d c b a        折叠加密后        c d
e f g h                         f e
                                b a
                                g h
reg[i]=1,表示从右到左折叠
a b c d e f g h  折叠加密后     h g f e
                               a b c d
f e           折叠加密后        e
c d                            d
b a                            a
g h                            h
                              f
                              c
                              b
                              g
```
解密过程与加密过程正好相反。
